{
  "language": "Solidity",
  "sources": {
    "contracts/Modicum.sol": {
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity ^0.8.6;\n// import \"hardhat/console.sol\";\n\ninterface ClientCallingContract {\n  function receiveJobResults(uint256 jobID, string calldata cid) external;\n}\n\ncontract Modicum {\n\n    uint256 penaltyRate;\n    address owner = msg.sender;\n    uint256 reactionDeadline;\n\n    modifier administrative {\n        if (msg.sender == owner)\n            _;\n        else\n            revert('You cannot call me!');\n        // _;\n    }\n\n    enum Architecture {\n        amd64,\n        armv7\n    }\n\n    struct JobCreator {\n        address[] trustedMediators;\n        uint256 itShouldntBeHere; //If I don't add it, I cannot make array of JC public\n    }\n\n    struct ResourceProvider {\n        address[] trustedMediators;\n        address[] trustedDirectories;\n        uint256[] supportedFirstLayers;\n        Architecture arch;\n        uint256 timePerInstruction;\n    }\n\n    struct Mediator {\n        Architecture arch;\n\n        uint256 instructionPrice;\n        uint256 bandwidthPrice;\n        address[] trustedDirectories;\n        uint256[] supportedFirstLayers;\n\n        uint256 availabilityValue;\n\n        uint256 verificationCount;\n    }\n\n    struct JobOfferPartOne {\n        address jobCreator;\n        uint256 depositValue;\n\n        uint256 instructionLimit;\n        uint256 bandwidthLimit;\n\n        uint256 instructionMaxPrice;\n        uint256 bandwidthMaxPrice;\n\n        uint256 completionDeadline;\n\n        uint256 matchIncentive;\n    }\n\n    struct JobOfferPartTwo {\n        address jobCreator;\n        uint256 ramLimit;\n        uint256 localStorageLimit;\n        string uri;\n        address directory;\n        uint256 jobHash;\n        Architecture arch;\n        string extras;\n    }\n\n    struct ResourceOffer {\n\n        address resProvider;\n        uint256 depositValue;\n\n        uint256 instructionPrice;\n        uint256 instructionCap;\n\n        uint256 memoryCap;\n        uint256 localStorageCap;\n\n        uint256 bandwidthCap;\n        uint256 bandwidthPrice;\n\n        uint256 matchIncentive;\n\n        uint256 verificationCount;\n    }\n\n    enum ResultStatus {\n        Completed,\n        Declined,\n        JobDescriptionError,\n        JobNotFound,\n        MemoryExceeded,\n        StorageExceeded,\n        InstructionsExceeded,\n        BandwidthExceeded,\n        ExceptionOccured,\n        DirectoryUnavailable\n//        LayerSizeExceeded,\n//        ResultNotFound\n    }\n\n    struct Match {\n        uint256 resourceOffer;\n        uint256 jobOffer;\n        address mediator;\n    }\n\n    struct JobResult {\n        ResultStatus status;\n        string uri;\n\n        uint256 matchId;\n\n        string hash;\n\n        uint256 instructionCount;\n        uint256 bandwidthUsage;\n\n        Reaction reacted;\n        uint256 timestamp;\n    }\n\n    struct MediatorResult {\n        ResultStatus status;\n        string uri;\n\n        uint256 matchId;\n\n        string hash;\n\n        uint256 instructionCount;\n        uint256 bandwidthUsage;\n\n        Verdict verdict;\n        Party faultyParty;\n    }\n\n    enum Party {\n        ResourceProvider,\n        JobCreator\n    }\n\n    enum Verdict {\n        ResultNotFound,\n        TooMuchCost,\n        WrongResults,\n        CorrectResults,\n        InvalidResultStatus\n    }\n\n    enum Reaction {\n        Accepted,\n        Rejected,\n        None\n    }\n\n    enum EtherTransferCause {\n        PostJobOffer,\n        PostResourceOffer,\n        CancelJobOffer,\n        CancelResOffer,\n        Punishment,\n        Mediation,\n        FinishingJob,\n        FinishingResource,\n        PostMatch,\n        MediatorAvailability\n    }\n\n    event Debug(uint64 value);\n    event DebugArch(Architecture arch);\n    event DebugUint(uint256 value);\n    event DebugString(string str);\n    event penaltyRateSet(uint256 penaltyRate);\n    event reactionDeadlineSet(uint256 reactionDeadline);\n\n    event ResultReaction(address addr, uint256 resultId, uint256 matchId, uint256 ResultReaction);\n    event ResultPosted(address addr, uint256 resultId, uint256 matchId, ResultStatus status, string uri,\n                       string hash, uint256 instructionCount, uint256 bandwidthUsage);\n    event Matched(address addr, uint256 matchId, uint256 jobOfferId, uint256 resourceOfferId, address mediator); //the same as job assigned.\n\n    event JobOfferPostedPartOne(uint256 offerId, uint256 ijoid, address addr, uint256 instructionLimit,\n                                uint256 bandwidthLimit, uint256 instructionMaxPrice, uint256 bandwidthMaxPrice, uint256 completionDeadline, uint256 deposit, uint256 matchIncentive);\n\n    event JobOfferPostedPartTwo(uint256 offerId, address addr, uint256 hash, string uri,\n                                address directory, Architecture arch, uint256 ramLimit, uint256 localStorageLimit, string extras);\n\n    event ResourceOfferPosted(uint256 offerId, address addr, uint256 instructionPrice,\n                              uint256 instructionCap, uint256 memoryCap, uint256 localStorageCap,\n                              uint256 bandwidthCap, uint256 bandwidthPrice, uint256 deposit, uint256 iroid);\n\n    event JobOfferCanceled(uint256 offerId);\n    event ResourceOfferCanceled(uint256 resOfferId);\n    event JobAssignedForMediation(address addr, uint256 matchId);\n\n    event MediatorRegistered(address addr, Architecture arch, uint256 instructionPrice, uint256 bandwidthPrice,\n                             uint256 availabilityValue, uint256 verificationCount);\n\n    event MediatorAddedSupportedFirstLayer(address addr, uint256 firstLayerHash);\n\n    event ResourceProviderRegistered(address addr, Architecture arch, uint256 timePerInstruction, uint256 penaltyRate);\n    event ResourceProviderAddedTrustedMediator(address addr, address mediator);\n    event JobCreatorRegistered(address addr, uint256 penaltyRate);\n    event JobCreatorAddedTrustedMediator(address addr, address mediator);\n    event MediatorAddedTrustedDirectory(address addr, address directory);\n    event ResourceProviderAddedTrustedDirectory(address addr, address directory);\n    event ResourceProviderAddedSupportedFirstLayer(address addr, uint256 firstLayer);\n\n    event MediationResultPosted(uint256 matchId, address addr, uint256 result, Party faultyParty, Verdict verdict, ResultStatus status,\n                                string uri, string hash, uint256 instructionCount, uint256 mediationCost);\n\n    event MatchClosed(uint256 matchId, uint256 cost);\n\n    event EtherTransferred(address _from, address to, uint256 value, EtherTransferCause cause);\n\n    mapping(address => Mediator) public mediators;\n    // mapping(uint256 => address) public mediator_index;\n    // uint mediator_count;\n    // address[] mediator_index;\n\n    mapping(address => ResourceProvider) resourceProviders;\n    mapping(address => JobCreator) jobCreators;\n\n    ResourceOffer[] resourceOffers;\n    uint256 joIndex = 1;\n    mapping(uint256 => JobOfferPartOne) jobOffersPartOne;\n    mapping(uint256 => JobOfferPartTwo) jobOffersPartTwo;\n    mapping(address => mapping(uint256 => uint256)) findJOIndex; // findJOIndex[addressOfJC][jcInternalOfferId]\n\n    Match[] matches;\n    JobResult[] results;\n    MediatorResult[] mediatorResults;\n\n    mapping(uint256 => bool) jobOfferPartOnePosted;\n    mapping(uint256 => bool) jobOfferPartTwoPosted;\n\n    mapping(uint256 => bool) mediationRequested;\n    mapping(uint256 => bool) mediated;\n    mapping(uint256 => uint256) matchToResult;\n    mapping(uint256 => bool) resultAvailable;\n\n    mapping(uint256 => bool) jobOfferMatched;\n    mapping(uint256 => bool) resOfferMatched;\n\n    mapping(uint256 => bool) isJobOfferCanceled;\n    mapping(uint256 => bool) isResOfferCanceled;\n    mapping(uint256 => bool) isMatchClosed;\n\n    uint256 internalRunModuleIncrementingID = 1;\n    mapping(uint256 => address) runModuleJobOwners;\n    address[] defaultMediators;\n    mapping(string => uint256) moduleCosts;\n    string[] moduleNames;\n\n    // used to enforce the deposit given by the compute provider\n    uint256 resourceProviderDepositMultiple = 0;\n\n    function test(uint256 value) public{\n      require(value > 0,\n      \"This should be greater than 0\");\n      emit DebugUint(value);\n    }\n\n    function check(Architecture arch) public{\n      //Architecture arch = Architecture.amd64;\n      emit Debug(5);\n      emit DebugArch(arch);\n      emit DebugUint(1);\n    }\n\n    function setPenaltyRate(uint256 _penaltyRate) public administrative {\n      penaltyRate = _penaltyRate;\n      emit penaltyRateSet(penaltyRate);\n    }\n\n    function setReactionDeadline(uint256 _reactionDeadline) public administrative {\n      reactionDeadline = _reactionDeadline;\n      emit reactionDeadlineSet(_reactionDeadline);\n    }\n\n    function setDefaultMediators(address[] calldata _defaultMediators) public administrative {\n      defaultMediators = _defaultMediators;\n    }\n\n    function setResourceProviderDepositMultiple(uint256 multiple) public administrative {\n      resourceProviderDepositMultiple = multiple;\n    }\n\n    function setModuleCost(string calldata name, uint256 cost) public administrative {\n      moduleCosts[name] = cost;\n      if(!stringExists(name, moduleNames)) {\n        moduleNames.push(name);\n      }\n    }\n\n    function getModuleCost(string calldata name) public view returns (uint256) {\n      return moduleCosts[name];\n    }\n\n    function getRequiredResourceProviderDeposit() public view returns (uint256) {\n      uint256 mostExpensiveModuleCost = 0;\n      // loop over moduleNames and if the moduleCosts is the most expensive - make it be the mostExpensiveModule\n      for(uint i = 0; i < moduleNames.length; i++) {\n        if(moduleCosts[moduleNames[i]] > mostExpensiveModuleCost) {\n          mostExpensiveModuleCost = moduleCosts[moduleNames[i]];\n        }\n      }\n      return mostExpensiveModuleCost * resourceProviderDepositMultiple;\n    }\n\n    function stringExists(string memory _myString, string[] memory _arr) public pure returns(bool) {\n      for(uint i = 0; i < _arr.length; i++) {\n        if(keccak256(bytes(_arr[i])) == keccak256(bytes(_myString))) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function registerMediator(\n        Architecture arch,\n        uint256 instructionPrice,\n        uint256 bandwidthPrice,\n        uint256 availabilityValue,\n        uint256 verificationCount\n    ) public {\n        address[] memory trustedDirectories;\n        uint256[] memory supportedFirstLayers;\n        mediators[msg.sender] = Mediator({\n            arch: arch,\n            instructionPrice: instructionPrice,\n            supportedFirstLayers: supportedFirstLayers,\n            bandwidthPrice: bandwidthPrice,\n            trustedDirectories: trustedDirectories,\n            availabilityValue: availabilityValue,\n            verificationCount: verificationCount\n            });\n        // console.log(\"🟢🟢🟢 EMIT MediatorRegistered\");\n        emit MediatorRegistered(msg.sender,\n            arch,\n            instructionPrice,\n            bandwidthPrice,\n            availabilityValue,\n            verificationCount\n        );\n    }\n\n    function mediatorAddTrustedDirectory(address directory) public {\n        mediators[msg.sender].trustedDirectories.push(directory);\n        emit MediatorAddedTrustedDirectory(msg.sender, directory);\n    }\n\n    function mediatorAddSupportedFirstLayer(uint256 firstLayerHash) public {\n        mediators[msg.sender].supportedFirstLayers.push(firstLayerHash);\n        emit MediatorAddedSupportedFirstLayer(msg.sender, firstLayerHash);\n    }\n\n    // function getMediatorTrustedDirectories(address mediator) public view returns (address[] memory) {\n    //     return mediators[mediator].trustedDirectories;\n    // }\n\n    function registerResourceProvider(\n        Architecture arch,\n        uint256 timePerInstruction\n    ) public {\n        // console.log(\"-----------------------------> RUNNING: ResourceProviderRegistered CHANGE1\");\n        address[] memory trustedMediators;\n        address[] memory trustedDirectories;\n        uint256[] memory supportedFirstLayers;\n        resourceProviders[msg.sender] = ResourceProvider({\n            trustedMediators: trustedMediators,\n            supportedFirstLayers: supportedFirstLayers,\n            arch: arch,\n            timePerInstruction: timePerInstruction,\n            trustedDirectories: trustedDirectories\n        });\n        // console.log(\"🟢🟢🟢 EMIT ResourceProviderRegistered\");\n        emit ResourceProviderRegistered(msg.sender,\n            arch,\n            timePerInstruction,\n            penaltyRate\n        );\n        // console.log(\"-----------------------------> EVENT EMITTED: ResourceProviderRegistered\");\n    }\n\n    function resourceProviderAddTrustedMediator(address mediator) public {\n        resourceProviders[msg.sender].trustedMediators.push(mediator);\n        // console.log(\"🟢🟢🟢 EMIT ResourceProviderAddedTrustedMediator\");\n        emit ResourceProviderAddedTrustedMediator(msg.sender, mediator);\n    }\n\n    function resourceProviderAddTrustedDirectory(address directory) public {\n        resourceProviders[msg.sender].trustedDirectories.push(directory);\n        emit ResourceProviderAddedTrustedDirectory(msg.sender, directory);\n    }\n\n    function resourceProviderAddSupportedFirstLayer(uint256 firstLayerHash) public {\n        resourceProviders[msg.sender].supportedFirstLayers.push(firstLayerHash);\n        emit ResourceProviderAddedSupportedFirstLayer(msg.sender, firstLayerHash);\n    }\n\n    // function getResourceProviderTrustedMediators(address rp) public view returns (address[] memory) {\n    //     return resourceProviders[rp].trustedMediators;\n    // }\n\n    // function getResourceProviderTrustedDirectories(address rp) public view returns(address[] memory) {\n    //     return resourceProviders[rp].trustedDirectories;\n    // }\n\n    function registerJobCreator(\n    ) public {\n        address[] memory trustedMediators;\n        jobCreators[msg.sender] = JobCreator({\n            trustedMediators: trustedMediators,\n            itShouldntBeHere: 0\n        });\n        // console.log(\"🟢🟢🟢 EMIT JobCreatorRegistered\");\n        emit JobCreatorRegistered(msg.sender, penaltyRate);\n    }\n\n    // function getJobCreatorTrustedMediators(address jc) public view returns (address[] memory) {\n    //     return jobCreators[jc].trustedMediators;\n    // }\n    function jobCreatorAddTrustedMediator(address mediator) public {\n        jobCreators[msg.sender].trustedMediators.push(mediator);\n        // console.log(\"🟢🟢🟢 EMIT JobCreatorAddedTrustedMediator\");\n        emit JobCreatorAddedTrustedMediator(msg.sender, mediator);\n    }\n\n    function postResOffer(\n        uint256 instructionPrice,\n        uint256 instructionCap,\n\n        uint256 memoryCap,\n        uint256 localStorageCap,\n\n        uint256 bandwidthCap,\n        uint256 bandwidthPrice,\n\n        uint256 matchIncentive,\n\n        uint256 verificationCount,\n\n        uint256 misc\n    ) public payable {\n        require(msg.value >= getRequiredResourceProviderDeposit(), \"You need to deposit more money to offer this resource\");\n        // require(resourceProviders[msg.sender].trustedMediators.length != 0,\n        //     \"You are not registered as a ResourceProvider\");\n\n        if (resourceProviders[msg.sender].trustedMediators.length == 0){\n            emit DebugString(\"trustedMediators==0\");\n        }\n\n        uint256 depositValue = (instructionPrice * instructionCap +\n            bandwidthCap * bandwidthPrice) * penaltyRate;\n\n        if (msg.value <= depositValue){\n            emit DebugString(\"msg.value <= depositValue\");\n            emit DebugUint(msg.value);\n            emit DebugUint(depositValue);\n        }\n\n        // require(msg.value >= depositValue,\n        //    \"You need to deposit more money to offer this resource\");\n\n        resourceOffers.push(ResourceOffer({\n          resProvider: msg.sender,\n          instructionPrice: instructionPrice,\n          instructionCap: instructionCap,\n          memoryCap: memoryCap,\n          localStorageCap: localStorageCap,\n          bandwidthCap: bandwidthCap,\n          bandwidthPrice: bandwidthPrice,\n          depositValue: msg.value,\n          matchIncentive: matchIncentive,\n          verificationCount: verificationCount\n        }));\n\n        uint256 index = resourceOffers.length - 1;\n\n        uint256 iroid = misc;\n        // console.log(\"🟢🟢🟢 EMIT ResourceOfferPosted\");\n        emit ResourceOfferPosted(index,\n\n            msg.sender,\n\n            instructionPrice,\n            instructionCap,\n\n            memoryCap,\n            localStorageCap,\n\n            bandwidthCap,\n            bandwidthPrice,\n\n            msg.value,\n\n            iroid\n        );\n\n        emit EtherTransferred(msg.sender, address(this), msg.value, EtherTransferCause.PostResourceOffer);\n    }\n\n    function stringReplaceAll(string memory _str, string memory _find, string memory _replace) private pure returns (string memory) {\n      bytes memory str = bytes(_str);\n      bytes memory find = bytes(_find);\n      bytes memory replace = bytes(_replace);\n      string memory result = \"\";\n\n      for(uint i = 0; i < str.length; i++) {\n        bool found = true;\n        for(uint j = 0; j < find.length && found; j++) {\n          if(i+j >= str.length || str[i+j] != find[j]) {\n            found = false;\n          }\n        }\n        if(found) {\n          result = string(abi.encodePacked(result, replace));\n          i += find.length - 1;\n        } else {\n          result = string(abi.encodePacked(result, string(abi.encodePacked(str[i]))));\n        }\n      }\n      return result;\n    }\n\n    function getModuleSpec(string calldata template, string calldata params) public pure returns (string memory) {\n      string memory saneTemplate = stringReplaceAll(template, \"\\\"\", \"\\\\\\\"\");\n      string memory saneParams = stringReplaceAll(params, \"\\\"\", \"\\\\\\\"\");\n      return string(abi.encodePacked(\"{\\\"template\\\": \\\"\", saneTemplate, \"\\\", \\\"params\\\": \\\"\", saneParams, \"\\\"}\"));\n    }\n\n    function _runModule(string calldata moduleName, string calldata params, address[] memory _mediators) private returns (uint256) {\n      require(_mediators.length > 0, \"No mediators provided\");\n      // * register job creator address\n      // * auto-assign jobid\n      // * record against the jobid, the calling address (so we can send results there)\n      // * postJobOfferPartOne\n      // * postJobOfferPartTwo\n      registerJobCreator();\n      jobCreatorAddTrustedMediator(_mediators[0]);\n      internalRunModuleIncrementingID++;\n      \n      uint256 jobID = postJobOfferPartOne(\n        moduleName,\n        internalRunModuleIncrementingID,\n        1,\n        1,\n        1,\n        1,\n        168933053300,\n        1\n      );\n      postJobOfferPartTwo(\n        internalRunModuleIncrementingID,\n        \"\",\n        address(0),\n        0,\n        Architecture.amd64,\n        getModuleSpec(moduleName, params)\n      );\n\n      runModuleJobOwners[jobID] = msg.sender;\n\n      return jobID;\n    }\n\n    function runModule(string calldata name, string calldata params, address[] calldata _mediators) external payable returns (uint256) {\n      return _runModule(name, params, _mediators);\n    }\n\n    function runModuleWithDefaultMediators(string calldata name, string calldata params) external payable returns (uint256) {\n      return _runModule(name, params, defaultMediators);\n    }\n\n    // NOTE: this is an example - so there are lots of \"require\" statements missing\n    // e.g. if the calling address is a contract - then we are running in \"client contract\" mode\n    // in this case - we should check the remote contract adheres to the required callback interface\n    // and throw if not otherwise this is a black hole for your dosh\n    function postJobOfferPartOne(\n        string memory moduleName,\n        uint256 ijoid,\n        uint256 instructionLimit,\n        uint256 bandwidthLimit,\n        uint256 instructionMaxPrice,\n        uint256 bandwidthMaxPrice,\n        uint256 completionDeadline,\n        uint256 matchIncentive\n    ) public payable returns (uint256) {\n        require(moduleCosts[moduleName] > 0, \"Module not found\");\n        require(msg.value >= moduleCosts[moduleName], \"Not enough funds sent for job\");\n      \n        // require(jobCreators[msg.sender].trustedMediators.length != 0,\n        //    \"You are not registered as a JobCreator\");\n\n        // require(msg.value >= (instructionLimit * instructionMaxPrice +\n        //    bandwidthLimit * bandwidthMaxPrice) * penaltyRate,\n        //    \"You need to deposit more money to request this job.\");\n\n        uint256 index = findJOIndex[msg.sender][ijoid];\n        if (index == 0) {\n            index = joIndex;\n            joIndex++;\n            findJOIndex[msg.sender][ijoid] = index;\n        }\n\n        // require(jobOfferPartOnePosted[index] == false, \"You have already posted a part one for this ijoid.\");\n\n        JobOfferPartOne memory joPOne = JobOfferPartOne({\n            jobCreator: msg.sender,\n            depositValue: msg.value,\n            instructionLimit: instructionLimit,\n            bandwidthLimit: bandwidthLimit,\n            // this means we are using the smart contract to control pricing\n            instructionMaxPrice: moduleCosts[moduleName],\n            bandwidthMaxPrice: bandwidthMaxPrice,\n            completionDeadline: completionDeadline,\n            matchIncentive: matchIncentive\n        });\n\n        jobOffersPartOne[index] = joPOne;\n        jobOfferPartOnePosted[index] = true;\n\n        // console.log(\"🟢🟢🟢 EMIT JobOfferPostedPartOne\");\n        emit JobOfferPostedPartOne(\n            index,\n            ijoid,\n            msg.sender,\n            instructionLimit,\n            bandwidthLimit,\n            instructionMaxPrice,\n            bandwidthMaxPrice,\n            completionDeadline,\n            msg.value,\n            matchIncentive\n        );\n\n        emit EtherTransferred(msg.sender, address(this), msg.value, EtherTransferCause.PostJobOffer);\n\n        return index;\n    }\n\n    function postJobOfferPartTwo(\n        uint256 ijoid,\n        string memory uri,\n        address directory,\n        uint256 jobHash,\n        Architecture arch,\n        string memory extras\n    ) public returns (uint256) {\n\n        // require(jobCreators[msg.sender].trustedMediators.length != 0,\n        //    \"You are not registered as a JobCreator\");\n\n        uint256 index = findJOIndex[msg.sender][ijoid];\n        if (index == 0) {\n            index = joIndex;\n            joIndex++;\n            findJOIndex[msg.sender][ijoid] = index;\n        }\n\n        // require(jobOfferPartTwoPosted[index] == false, \"You have already posted a part two for this ijoid.\");\n\n        JobOfferPartTwo memory joPTwo = JobOfferPartTwo({\n            jobCreator: msg.sender,\n            ramLimit: 0,\n            localStorageLimit: 0,\n            uri: uri,\n            directory: directory,\n            jobHash: jobHash,\n            arch: arch,\n            extras: extras\n        });\n\n        jobOffersPartTwo[index] = joPTwo;\n        jobOfferPartTwoPosted[index] = true;\n\n        // console.log(\"🟢🟢🟢 EMIT JobOfferPostedPartTwo\");\n        emit JobOfferPostedPartTwo(\n            index,\n            msg.sender,\n            jobHash,\n            uri,\n            directory,\n            arch,\n            0,\n            0,\n            extras\n        );\n\n        return index;\n    }\n\n    // function cancelJobOffer(uint256 offerId) public {\n    //     // require(jobOffersPartOne[offerId].jobCreator == msg.sender, \"This offer is not yours.\");\n    //     // require(jobOfferMatched[offerId] == false, \"You cannot cancel a jop which is running.\");\n\n    //     //msg.sender.transfer(jobOffersPartOne[offerId].depositValue);\n    //     jobOffersPartOne[offerId].depositValue = 0;\n\n    //     isJobOfferCanceled[offerId] = true;\n\n    //     emit JobOfferCanceled(offerId);\n    //     emit EtherTransferred(address(this), msg.sender, jobOffersPartOne[offerId].depositValue, EtherTransferCause.CancelJobOffer);\n    // }\n\n    // function cancelResOffer(uint256 offerId) public {\n    //     // require(resourceOffers[offerId].resProvider == msg.sender, \"This offer is not yours.\");\n    //     // require(resOfferMatched[offerId] == false, \"You cannot cancel a jop which is running.\");\n\n    //     //msg.sender.transfer(resourceOffers[offerId].depositValue);\n    //     resourceOffers[offerId].depositValue = 0;\n\n    //     isResOfferCanceled[offerId] = true;\n\n    //     emit ResourceOfferCanceled(offerId);\n    //     emit EtherTransferred(address(this), msg.sender, resourceOffers[offerId].depositValue, EtherTransferCause.CancelResOffer);\n    // }\n\n    function postMatch(\n        uint256 jobOfferId,\n        uint256 resourceOfferId,\n        address mediator\n    ) public returns (uint256){\n        // require(solvers[msg.sender] == true, \"You are not a trusted solver\");\n        // require(isJobOfferCanceled[jobOfferId] == false,\n        //     \"Job offer is already canceled.\");\n\n        // require(isResOfferCanceled[resourceOfferId] == false,\n        //     \"Resource offer is already canceled.\");\n\n        // require(jobOfferMatched[jobOfferId] == false,\n        //     \"Job offer is already matched\");\n\n        // require(resOfferMatched[resourceOfferId] == false,\n        //     \"Resource offer is already matched\");\n\n        // require(jobOfferPartOnePosted[jobOfferId] == true,\n        //     \"The job offer was not completed\");\n        // require(jobOfferPartTwoPosted[jobOfferId] == true,\n        //     \"The job offer was not completed\");\n        // bool RPTrustM = false;\n        // bool JCTrustM = false;\n        // bool RPTrustD = false;\n        // bool MTrustD  = false;\n        // bool RPSupportFirstLayer = false;\n        // bool MSupportFirstLayer = false;\n\n        // uint i = 0;\n\n        // for (i = 0; i < resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedMediators.length; i++)\n        //     if (resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedMediators[i] == mediator)\n        //         RPTrustM = true;\n\n        // for (i = 0; i < jobCreators[jobOffersPartOne[jobOfferId].jobCreator].trustedMediators.length; i++)\n        //     if (jobCreators[jobOffersPartOne[jobOfferId].jobCreator].trustedMediators[i] == mediator)\n        //         JCTrustM = true;\n\n        // for (i = 0; i < resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedDirectories.length; i++)\n        //     if (resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedDirectories[i] == jobOffersPartTwo[jobOfferId].directory)\n        //         RPTrustD = true;\n\n        // for (i = 0; i < mediators[mediator].trustedDirectories.length; i++)\n        //     if (mediators[mediator].trustedDirectories[i] == jobOffersPartTwo[jobOfferId].directory)\n        //         RPTrustD = true;\n\n        // for (i = 0; i < resourceProviders[resourceOffers[resourceOfferId].resProvider].supportedFirstLayers.length; i++)\n        //     if (resourceProviders[resourceOffers[resourceOfferId].resProvider].supportedFirstLayers[i] == jobOffersPartTwo[jobOfferId].firstLayerHash)\n        //         RPSupportFirstLayer = true;\n\n        // for (i = 0; i < mediators[mediator].supportedFirstLayers.length; i++)\n        //     if (mediators[mediator].supportedFirstLayers[i] == jobOffersPartTwo[jobOfferId].firstLayerHash)\n        //         MSupportFirstLayer = true;\n\n\n        // require(\n        //     resourceOffers[resourceOfferId].instructionCap >= jobOffersPartOne[jobOfferId].instructionLimit &&\n        //     resourceOffers[resourceOfferId].memoryCap >= jobOffersPartTwo[jobOfferId].ramLimit &&\n        //     resourceOffers[resourceOfferId].localStorageCap >= jobOffersPartTwo[jobOfferId].localStorageLimit &&\n        //     resourceOffers[resourceOfferId].instructionPrice <= jobOffersPartOne[jobOfferId].instructionMaxPrice &&\n        //     resourceProviders[resourceOffers[resourceOfferId].resProvider].arch == jobOffersPartTwo[jobOfferId].arch && mediators[mediator].arch == resourceProviders[resourceOffers[resourceOfferId].resProvider].arch &&\n        //     resourceOffers[resourceOfferId].verificationCount <= mediators[mediator].verificationCount &&\n        //     now + resourceProviders[resourceOffers[resourceOfferId].resProvider].timePerInstruction * jobOffersPartOne[jobOfferId].instructionLimit <= jobOffersPartOne[jobOfferId].completionDeadline &&\n        //     RPTrustD && RPTrustM && JCTrustM && MTrustD && RPSupportFirstLayer && MSupportFirstLayer,\n        //     \"The offers cannot be matched\"\n        // );\n\n        matches.push(Match({\n          resourceOffer: resourceOfferId,\n          jobOffer: jobOfferId,\n          mediator: mediator\n        }));\n\n        uint256 index = matches.length - 1;\n\n        jobOfferMatched[jobOfferId] = true;\n        resOfferMatched[resourceOfferId] = true;\n\n        uint256 matchIncentive = jobOffersPartOne[jobOfferId].matchIncentive +\n                resourceOffers[resourceOfferId].matchIncentive;\n\n        //msg.sender.transfer(matchIncentive);\n\n        emit EtherTransferred(address(this), msg.sender, matchIncentive, EtherTransferCause.PostMatch);\n\n        // console.log(\"🟢🟢🟢 EMIT Matched\");\n        emit Matched(msg.sender, index, jobOfferId, resourceOfferId, mediator);\n\n        return index;\n    }\n\n    function postResult(\n        uint256 matchId,\n        uint256 jobOfferId,\n        ResultStatus status,\n        string calldata uri,\n        string calldata hash,\n        uint256 instructionCount,\n        uint256 bandwidthUsage\n    ) public returns (uint256) {\n        require(jobOfferId >= 0);\n\n        // console.log(\"🟢🟢🟢 postResult\");\n        // require (resourceOffers[matches[matchId].resourceOffer].resProvider == msg.sender,\n        //     \"You are not supposed to publish result for this match.\");\n\n        // require(isMatchClosed[matchId] == false,\n        //     \"This match is already closed.\");\n\n        results.push(JobResult({\n          status: status,\n          matchId: matchId,\n          uri: uri,\n          instructionCount: instructionCount,\n          bandwidthUsage: bandwidthUsage,\n          hash: hash,\n          reacted: Reaction.None,\n          timestamp: block.timestamp\n        }));\n        uint256 index = results.length - 1;\n\n        matchToResult[matchId] = index;\n        resultAvailable[matchId] = true;\n\n        // console.log(\"ResultPosted event\");\n        emit ResultPosted(\n            msg.sender,\n            index,\n            matchId,\n            status,\n            uri,\n            hash,\n            instructionCount,\n            bandwidthUsage\n        );\n\n        if(runModuleJobOwners[jobOfferId] != address(0)) {\n          ClientCallingContract(runModuleJobOwners[jobOfferId]).receiveJobResults(jobOfferId, hash);\n          close(matchId);\n        }\n\n        return index;\n    }\n\n    function rejectResult(uint256 resultId) public {\n        results[resultId].reacted = Reaction.Rejected;\n        mediationRequested[results[resultId].matchId] = true;\n\n        emit ResultReaction(msg.sender, resultId,results[resultId].matchId,  1);\n\n        emit DebugString(\"result rejected\");\n\n        emit JobAssignedForMediation(msg.sender, results[resultId].matchId);\n    }\n\n    function acceptResult(uint256 resultId) public returns (uint256) {\n        results[resultId].reacted = Reaction.Accepted;\n\n        emit ResultReaction(msg.sender, resultId,results[resultId].matchId,  0);\n\n        emit DebugString(\"result accepted\");\n\n        return close(results[resultId].matchId);\n    }\n\n    function postMediationResult(\n        uint256 matchId,\n        uint256 jobOfferId,\n        ResultStatus status,\n        string calldata uri,\n\n        string calldata hash,\n\n        Verdict verdict,\n        Party faultyParty\n    ) public returns (Party) {\n        require(jobOfferId >= 0);\n        JobOfferPartOne memory jo = jobOffersPartOne[matches[matchId].jobOffer];\n        mediated[matchId] = true;\n\n        mediatorResults.push(MediatorResult({\n          status: status,\n          uri: uri,\n          matchId: matchId,\n          hash: hash,\n          instructionCount: 0,\n          bandwidthUsage: 0,\n          verdict: verdict,\n          faultyParty: faultyParty\n        }));\n\n        emit MediationResultPosted(matchId, msg.sender, mediatorResults.length - 1, faultyParty, verdict, status, uri, hash, 0, jo.instructionMaxPrice);\n\n        if(verdict == Verdict.WrongResults) {\n          punishResourceProvider(matchId);\n        } else {\n          close(matchId);\n        }\n        \n        return faultyParty;\n    }\n\n    function punishResourceProvider(uint256 matchId) private returns (uint256)  {\n      require(isMatchClosed[matchId] == false, \"This match is already closed.\");\n      JobOfferPartOne memory jo = jobOffersPartOne[matches[matchId].jobOffer];\n      isMatchClosed[matchId] = true;\n      payable(address(jo.jobCreator)).transfer(jo.depositValue);\n      emit MatchClosed(matchId, jo.instructionMaxPrice);\n      emit EtherTransferred(address(this), jo.jobCreator, jo.depositValue, EtherTransferCause.Mediation);\n      return jo.instructionMaxPrice;\n    }\n\n    function close(uint256 matchId) private returns (uint256) {\n      require(isMatchClosed[matchId] == false, \"This match is already closed.\");\n      ResourceOffer memory ro = resourceOffers[matches[matchId].resourceOffer];\n      JobOfferPartOne memory jo = jobOffersPartOne[matches[matchId].jobOffer];\n      isMatchClosed[matchId] = true;\n      payable(address(ro.resProvider)).transfer(ro.depositValue + jo.instructionMaxPrice);\n      emit MatchClosed(matchId, jo.instructionMaxPrice);\n      emit EtherTransferred(address(this), ro.resProvider, ro.depositValue + jo.instructionMaxPrice, EtherTransferCause.FinishingJob);\n      return jo.instructionMaxPrice;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}