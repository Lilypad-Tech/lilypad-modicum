{
  "language": "Solidity",
  "sources": {
    "contracts/Modicum.sol": {
      "content": "pragma solidity ^0.4.25;\n// import \"hardhat/console.sol\";\n\ncontract Modicum {\n\n    uint256 penaltyRate;\n    address owner = msg.sender;\n    uint256 reactionDeadline;\n\n    modifier administrative {\n        if (msg.sender == owner)\n            _;\n        else\n            revert('You cannot call me!');\n        // _;\n    }\n\n    enum Architecture {\n        amd64,\n        armv7\n    }\n\n    struct JobCreator {\n        address[] trustedMediators;\n        uint256 itShouldntBeHere; //If I don't add it, I cannot make array of JC public\n    }\n\n    struct ResourceProvider {\n        address[] trustedMediators;\n        address[] trustedDirectories;\n        uint256[] supportedFirstLayers;\n        Architecture arch;\n        uint256 timePerInstruction;\n    }\n\n    struct Mediator {\n        Architecture arch;\n\n        uint256 instructionPrice;\n        uint256 bandwidthPrice;\n        address[] trustedDirectories;\n        uint256[] supportedFirstLayers;\n\n        uint256 availabilityValue;\n\n        uint256 verificationCount;\n    }\n\n    struct JobOfferPartOne {\n        address jobCreator;\n        uint256 depositValue;\n\n        uint256 instructionLimit;\n        uint256 bandwidthLimit;\n\n        uint256 instructionMaxPrice;\n        uint256 bandwidthMaxPrice;\n\n        uint256 completionDeadline;\n\n        uint256 matchIncentive;\n    }\n\n    struct JobOfferPartTwo {\n        address jobCreator;\n        uint256 ramLimit;\n        uint256 localStorageLimit;\n        string uri;\n        address directory;\n        uint256 jobHash;\n        Architecture arch;\n        string extras;\n    }\n\n    struct ResourceOffer {\n\n        address resProvider;\n        uint256 depositValue;\n\n        uint256 instructionPrice;\n        uint256 instructionCap;\n\n        uint256 memoryCap;\n        uint256 localStorageCap;\n\n        uint256 bandwidthCap;\n        uint256 bandwidthPrice;\n\n        uint256 matchIncentive;\n\n        uint256 verificationCount;\n    }\n\n    enum ResultStatus {\n        Completed,\n        Declined,\n        JobDescriptionError,\n        JobNotFound,\n        MemoryExceeded,\n        StorageExceeded,\n        InstructionsExceeded,\n        BandwidthExceeded,\n        ExceptionOccured,\n        DirectoryUnavailable\n//        LayerSizeExceeded,\n//        ResultNotFound\n    }\n\n    struct Match {\n        uint256 resourceOffer;\n        uint256 jobOffer;\n        address mediator;\n    }\n\n    struct JobResult {\n        ResultStatus status;\n        string uri;\n\n        uint256 matchId;\n\n        string hash;\n\n        uint256 instructionCount;\n        uint256 bandwidthUsage;\n\n        Reaction reacted;\n        uint256 timestamp;\n    }\n\n    struct MediatorResult {\n        ResultStatus status;\n        string uri;\n\n        uint256 matchId;\n\n        string hash;\n\n        uint256 instructionCount;\n        uint256 bandwidthUsage;\n\n        Verdict verdict;\n        Party faultyParty;\n    }\n\n    enum Party {\n        ResourceProvider,\n        JobCreator\n    }\n\n    enum Verdict {\n        ResultNotFound,\n        TooMuchCost,\n        WrongResults,\n        CorrectResults,\n        InvalidResultStatus\n    }\n\n    enum Reaction {\n        Accepted,\n        Rejected,\n        None\n    }\n\n    enum EtherTransferCause {\n        PostJobOffer,\n        PostResourceOffer,\n        CancelJobOffer,\n        CancelResOffer,\n        Punishment,\n        Mediation,\n        FinishingJob,\n        FinishingResource,\n        PostMatch,\n        MediatorAvailability\n    }\n\n    event Debug(uint64 value);\n    event DebugArch(Architecture arch);\n    event DebugUint(uint256 value);\n    event DebugString(string str);\n    event penaltyRateSet(uint256 penaltyRate);\n    event reactionDeadlineSet(uint256 reactionDeadline);\n\n    event ResultReaction(address addr, uint256 resultId, uint256 matchId, uint256 ResultReaction);\n    event ResultPosted(address addr, uint256 resultId, uint256 matchId, ResultStatus status, string uri,\n                       string hash, uint256 instructionCount, uint256 bandwidthUsage);\n    event Matched(address addr, uint256 matchId, uint256 jobOfferId, uint256 resourceOfferId, address mediator); //the same as job assigned.\n\n    event JobOfferPostedPartOne(uint256 offerId, uint256 ijoid, address addr, uint256 instructionLimit,\n                                uint256 bandwidthLimit, uint256 instructionMaxPrice, uint256 bandwidthMaxPrice, uint256 completionDeadline, uint256 deposit, uint256 matchIncentive);\n\n    event JobOfferPostedPartTwo(uint256 offerId, address addr, uint256 hash, string uri,\n                                address directory, Architecture arch, uint256 ramLimit, uint256 localStorageLimit, string extras);\n\n    event ResourceOfferPosted(uint256 offerId, address addr, uint256 instructionPrice,\n                              uint256 instructionCap, uint256 memoryCap, uint256 localStorageCap,\n                              uint256 bandwidthCap, uint256 bandwidthPrice, uint256 deposit, uint256 iroid);\n\n    event JobOfferCanceled(uint256 offerId);\n    event ResourceOfferCanceled(uint256 resOfferId);\n    event JobAssignedForMediation(address addr, uint256 matchId);\n\n    event MediatorRegistered(address addr, Architecture arch, uint256 instructionPrice, uint256 bandwidthPrice,\n                             uint256 availabilityValue, uint256 verificationCount);\n\n    event MediatorAddedSupportedFirstLayer(address addr, uint256 firstLayerHash);\n\n    event ResourceProviderRegistered(address addr, Architecture arch, uint256 timePerInstruction, uint256 penaltyRate);\n    event ResourceProviderAddedTrustedMediator(address addr, address mediator);\n    event JobCreatorRegistered(address addr, uint256 penaltyRate);\n    event JobCreatorAddedTrustedMediator(address addr, address mediator);\n    event MediatorAddedTrustedDirectory(address addr, address directory);\n    event ResourceProviderAddedTrustedDirectory(address addr, address directory);\n    event ResourceProviderAddedSupportedFirstLayer(address addr, uint256 firstLayer);\n\n    event MediationResultPosted(uint256 matchId, address addr, uint256 result, Party faultyParty, Verdict verdict, ResultStatus status,\n                                string uri, string hash, uint256 instructionCount, uint256 mediationCost);\n\n    event MatchClosed(uint256 matchId, uint256 cost);\n\n    event EtherTransferred(address _from, address to, uint256 value, EtherTransferCause cause);\n\n    mapping(address => Mediator) public mediators;\n    // mapping(uint256 => address) public mediator_index;\n    // uint mediator_count;\n    // address[] mediator_index;\n\n    mapping(address => ResourceProvider) resourceProviders;\n    mapping(address => JobCreator) jobCreators;\n\n    ResourceOffer[] resourceOffers;\n    uint256 joIndex = 1;\n    mapping(uint256 => JobOfferPartOne) jobOffersPartOne;\n    mapping(uint256 => JobOfferPartTwo) jobOffersPartTwo;\n    mapping(address => mapping(uint256 => uint256)) findJOIndex; // findJOIndex[addressOfJC][jcInternalOfferId]\n\n    Match[] matches;\n    JobResult[] results;\n    MediatorResult[] mediatorResults;\n\n    mapping(uint256 => bool) jobOfferPartOnePosted;\n    mapping(uint256 => bool) jobOfferPartTwoPosted;\n\n    mapping(uint256 => bool) mediationRequested;\n    mapping(uint256 => bool) mediated;\n    mapping(uint256 => uint256) matchToResult;\n    mapping(uint256 => bool) resultAvailable;\n\n    mapping(uint256 => bool) jobOfferMatched;\n    mapping(uint256 => bool) resOfferMatched;\n\n    mapping(uint256 => bool) isJobOfferCanceled;\n    mapping(uint256 => bool) isResOfferCanceled;\n    mapping(uint256 => bool) isMatchClosed;\n\n    function () external payable {\n        revert(\"Why are you calling me?\");\n    }\n\n    function test(uint256 value) public{\n      require(value > 0,\n      \"This should be greater than 0\");\n      emit DebugUint(value);\n    }\n\n    function check(Architecture arch) public{\n        //Architecture arch = Architecture.amd64;\n        emit Debug(5);\n        emit DebugArch(arch);\n        emit DebugUint(1);\n    }\n\n    function setPenaltyRate(uint256 _penaltyRate) public administrative {\n        penaltyRate = _penaltyRate;\n        emit penaltyRateSet(penaltyRate);\n    }\n\n    function setReactionDeadline(uint256 _reactionDeadline) public administrative {\n        reactionDeadline = _reactionDeadline;\n        emit reactionDeadlineSet(_reactionDeadline);\n    }\n\n\n    function registerMediator(\n        Architecture arch,\n        uint256 instructionPrice,\n        uint256 bandwidthPrice,\n        uint256 availabilityValue,\n        uint256 verificationCount\n    ) public {\n        address[] memory trustedDirectories;\n        uint256[] memory supportedFirstLayers;\n        mediators[msg.sender] = Mediator({\n            arch: arch,\n            instructionPrice: instructionPrice,\n            supportedFirstLayers: supportedFirstLayers,\n            bandwidthPrice: bandwidthPrice,\n            trustedDirectories: trustedDirectories,\n            availabilityValue: availabilityValue,\n            verificationCount: verificationCount\n            });\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT MediatorRegistered\");\n        emit MediatorRegistered(msg.sender,\n            arch,\n            instructionPrice,\n            bandwidthPrice,\n            availabilityValue,\n            verificationCount\n        );\n    }\n\n    function mediatorAddTrustedDirectory(address directory) public {\n        mediators[msg.sender].trustedDirectories.push(directory);\n        emit MediatorAddedTrustedDirectory(msg.sender, directory);\n    }\n\n    function mediatorAddSupportedFirstLayer(uint256 firstLayerHash) public {\n        mediators[msg.sender].supportedFirstLayers.push(firstLayerHash);\n        emit MediatorAddedSupportedFirstLayer(msg.sender, firstLayerHash);\n    }\n\n    // function getMediatorTrustedDirectories(address mediator) public view returns (address[] memory) {\n    //     return mediators[mediator].trustedDirectories;\n    // }\n\n    function registerResourceProvider(\n        Architecture arch,\n        uint256 timePerInstruction\n    ) public {\n        // console.log(\"-----------------------------> RUNNING: ResourceProviderRegistered CHANGE1\");\n        address[] memory trustedMediators;\n        address[] memory trustedDirectories;\n        uint256[] memory supportedFirstLayers;\n        resourceProviders[msg.sender] = ResourceProvider({\n            trustedMediators: trustedMediators,\n            supportedFirstLayers: supportedFirstLayers,\n            arch: arch,\n            timePerInstruction: timePerInstruction,\n            trustedDirectories: trustedDirectories\n        });\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT ResourceProviderRegistered\");\n        emit ResourceProviderRegistered(msg.sender,\n            arch,\n            timePerInstruction,\n            penaltyRate\n        );\n        // console.log(\"-----------------------------> EVENT EMITTED: ResourceProviderRegistered\");\n    }\n\n    function resourceProviderAddTrustedMediator(address mediator) public {\n        resourceProviders[msg.sender].trustedMediators.push(mediator);\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT ResourceProviderAddedTrustedMediator\");\n        emit ResourceProviderAddedTrustedMediator(msg.sender, mediator);\n    }\n\n    function resourceProviderAddTrustedDirectory(address directory) public {\n        resourceProviders[msg.sender].trustedDirectories.push(directory);\n        emit ResourceProviderAddedTrustedDirectory(msg.sender, directory);\n    }\n\n    function resourceProviderAddSupportedFirstLayer(uint256 firstLayerHash) public {\n        resourceProviders[msg.sender].supportedFirstLayers.push(firstLayerHash);\n        emit ResourceProviderAddedSupportedFirstLayer(msg.sender, firstLayerHash);\n    }\n\n    // function getResourceProviderTrustedMediators(address rp) public view returns (address[] memory) {\n    //     return resourceProviders[rp].trustedMediators;\n    // }\n\n    // function getResourceProviderTrustedDirectories(address rp) public view returns(address[] memory) {\n    //     return resourceProviders[rp].trustedDirectories;\n    // }\n\n    function registerJobCreator(\n    ) public {\n        address[] memory trustedMediators;\n        jobCreators[msg.sender] = JobCreator({\n            trustedMediators: trustedMediators,\n            itShouldntBeHere: 0\n        });\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT JobCreatorRegistered\");\n        emit JobCreatorRegistered(msg.sender, penaltyRate);\n    }\n\n    // function getJobCreatorTrustedMediators(address jc) public view returns (address[] memory) {\n    //     return jobCreators[jc].trustedMediators;\n    // }\n    function jobCreatorAddTrustedMediator(address mediator) public {\n        jobCreators[msg.sender].trustedMediators.push(mediator);\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT JobCreatorAddedTrustedMediator\");\n        emit JobCreatorAddedTrustedMediator(msg.sender, mediator);\n    }\n\n    function postResOffer(\n        uint256 instructionPrice,\n        uint256 instructionCap,\n\n        uint256 memoryCap,\n        uint256 localStorageCap,\n\n        uint256 bandwidthCap,\n        uint256 bandwidthPrice,\n\n        uint256 matchIncentive,\n\n        uint256 verificationCount,\n\n        uint256 misc\n    ) public payable {\n        // require(resourceProviders[msg.sender].trustedMediators.length != 0,\n        //     \"You are not registered as a ResourceProvider\");\n\n        if (resourceProviders[msg.sender].trustedMediators.length == 0){\n            emit DebugString(\"trustedMediators==0\");\n        }\n\n        uint256 depositValue = (instructionPrice * instructionCap +\n            bandwidthCap * bandwidthPrice) * penaltyRate;\n\n        if (msg.value <= depositValue){\n            emit DebugString(\"msg.value <= depositValue\");\n            emit DebugUint(msg.value);\n            emit DebugUint(depositValue);\n        }\n\n        // require(msg.value >= depositValue,\n        //    \"You need to deposit more money to offer this resource\");\n\n        uint256 index = resourceOffers.push(ResourceOffer({\n            resProvider: msg.sender,\n            instructionPrice: instructionPrice,\n            instructionCap: instructionCap,\n            memoryCap: memoryCap,\n            localStorageCap: localStorageCap,\n            bandwidthCap: bandwidthCap,\n            bandwidthPrice: bandwidthPrice,\n            depositValue: msg.value,\n            matchIncentive: matchIncentive,\n            verificationCount: verificationCount\n            })) - 1;\n\n        uint256 iroid = misc;\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT ResourceOfferPosted\");\n        emit ResourceOfferPosted(index,\n\n            msg.sender,\n\n            instructionPrice,\n            instructionCap,\n\n            memoryCap,\n            localStorageCap,\n\n            bandwidthCap,\n            bandwidthPrice,\n\n            msg.value,\n\n            iroid\n        );\n\n        emit EtherTransferred(msg.sender, address(this), msg.value, EtherTransferCause.PostResourceOffer);\n    }\n\n    function postJobOfferPartOne(\n        uint256 ijoid,\n        uint256 instructionLimit,\n        uint256 bandwidthLimit,\n        uint256 instructionMaxPrice,\n        uint256 bandwidthMaxPrice,\n        uint256 completionDeadline,\n        uint256 matchIncentive\n    ) public payable {\n        // require(jobCreators[msg.sender].trustedMediators.length != 0,\n        //    \"You are not registered as a JobCreator\");\n\n        // require(msg.value >= (instructionLimit * instructionMaxPrice +\n        //    bandwidthLimit * bandwidthMaxPrice) * penaltyRate,\n        //    \"You need to deposit more money to request this job.\");\n\n        uint256 index = findJOIndex[msg.sender][ijoid];\n        if (index == 0) {\n            index = joIndex;\n            joIndex++;\n            findJOIndex[msg.sender][ijoid] = index;\n        }\n\n        // require(jobOfferPartOnePosted[index] == false, \"You have already posted a part one for this ijoid.\");\n\n        JobOfferPartOne memory joPOne = JobOfferPartOne({\n            jobCreator: msg.sender,\n            depositValue: msg.value,\n            instructionLimit: instructionLimit,\n            bandwidthLimit: bandwidthLimit,\n            instructionMaxPrice: instructionMaxPrice,\n            bandwidthMaxPrice: bandwidthMaxPrice,\n            completionDeadline: completionDeadline,\n            matchIncentive: matchIncentive\n        });\n\n        jobOffersPartOne[index] = joPOne;\n        jobOfferPartOnePosted[index] = true;\n\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT JobOfferPostedPartOne\");\n        emit JobOfferPostedPartOne(\n            index,\n            ijoid,\n            msg.sender,\n            instructionLimit,\n            bandwidthLimit,\n            instructionMaxPrice,\n            bandwidthMaxPrice,\n            completionDeadline,\n            msg.value,\n            matchIncentive\n        );\n\n        emit EtherTransferred(msg.sender, address(this), msg.value, EtherTransferCause.PostJobOffer);\n    }\n\n    function postJobOfferPartTwo(\n        uint256 ijoid,\n        uint256 ramLimit,\n        uint256 localStorageLimit,\n        string uri,\n        address directory,\n        uint256 jobHash,\n        Architecture arch,\n        string extras\n    ) public {\n\n        // require(jobCreators[msg.sender].trustedMediators.length != 0,\n        //    \"You are not registered as a JobCreator\");\n\n        uint256 index = findJOIndex[msg.sender][ijoid];\n        if (index == 0) {\n            index = joIndex;\n            joIndex++;\n            findJOIndex[msg.sender][ijoid] = index;\n        }\n\n        // require(jobOfferPartTwoPosted[index] == false, \"You have already posted a part two for this ijoid.\");\n\n        JobOfferPartTwo memory joPTwo = JobOfferPartTwo({\n            jobCreator: msg.sender,\n            ramLimit: ramLimit,\n            localStorageLimit: localStorageLimit,\n            uri: uri,\n            directory: directory,\n            jobHash: jobHash,\n            arch: arch,\n            extras: extras\n        });\n\n        jobOffersPartTwo[index] = joPTwo;\n        jobOfferPartTwoPosted[index] = true;\n\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT JobOfferPostedPartTwo\");\n        emit JobOfferPostedPartTwo(\n            index,\n            msg.sender,\n            jobHash,\n            uri,\n            directory,\n            arch,\n            ramLimit,\n            localStorageLimit,\n            extras\n        );\n    }\n\n    function cancelJobOffer(uint256 offerId) public {\n        // require(jobOffersPartOne[offerId].jobCreator == msg.sender, \"This offer is not yours.\");\n        // require(jobOfferMatched[offerId] == false, \"You cannot cancel a jop which is running.\");\n\n        //msg.sender.transfer(jobOffersPartOne[offerId].depositValue);\n        jobOffersPartOne[offerId].depositValue = 0;\n\n        isJobOfferCanceled[offerId] = true;\n\n        emit JobOfferCanceled(offerId);\n        emit EtherTransferred(address(this), msg.sender, jobOffersPartOne[offerId].depositValue, EtherTransferCause.CancelJobOffer);\n    }\n\n    function cancelResOffer(uint256 offerId) public {\n        // require(resourceOffers[offerId].resProvider == msg.sender, \"This offer is not yours.\");\n        // require(resOfferMatched[offerId] == false, \"You cannot cancel a jop which is running.\");\n\n        //msg.sender.transfer(resourceOffers[offerId].depositValue);\n        resourceOffers[offerId].depositValue = 0;\n\n        isResOfferCanceled[offerId] = true;\n\n        emit ResourceOfferCanceled(offerId);\n        emit EtherTransferred(address(this), msg.sender, resourceOffers[offerId].depositValue, EtherTransferCause.CancelResOffer);\n    }\n\n    function postMatch(\n        uint256 jobOfferId,\n        uint256 resourceOfferId,\n        address mediator\n    ) public returns (uint256){\n        // require(solvers[msg.sender] == true, \"You are not a trusted solver\");\n        // require(isJobOfferCanceled[jobOfferId] == false,\n        //     \"Job offer is already canceled.\");\n\n        // require(isResOfferCanceled[resourceOfferId] == false,\n        //     \"Resource offer is already canceled.\");\n\n        // require(jobOfferMatched[jobOfferId] == false,\n        //     \"Job offer is already matched\");\n\n        // require(resOfferMatched[resourceOfferId] == false,\n        //     \"Resource offer is already matched\");\n\n        // require(jobOfferPartOnePosted[jobOfferId] == true,\n        //     \"The job offer was not completed\");\n        // require(jobOfferPartTwoPosted[jobOfferId] == true,\n        //     \"The job offer was not completed\");\n        // bool RPTrustM = false;\n        // bool JCTrustM = false;\n        // bool RPTrustD = false;\n        // bool MTrustD  = false;\n        // bool RPSupportFirstLayer = false;\n        // bool MSupportFirstLayer = false;\n\n        // uint i = 0;\n\n        // for (i = 0; i < resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedMediators.length; i++)\n        //     if (resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedMediators[i] == mediator)\n        //         RPTrustM = true;\n\n        // for (i = 0; i < jobCreators[jobOffersPartOne[jobOfferId].jobCreator].trustedMediators.length; i++)\n        //     if (jobCreators[jobOffersPartOne[jobOfferId].jobCreator].trustedMediators[i] == mediator)\n        //         JCTrustM = true;\n\n        // for (i = 0; i < resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedDirectories.length; i++)\n        //     if (resourceProviders[resourceOffers[resourceOfferId].resProvider].trustedDirectories[i] == jobOffersPartTwo[jobOfferId].directory)\n        //         RPTrustD = true;\n\n        // for (i = 0; i < mediators[mediator].trustedDirectories.length; i++)\n        //     if (mediators[mediator].trustedDirectories[i] == jobOffersPartTwo[jobOfferId].directory)\n        //         RPTrustD = true;\n\n        // for (i = 0; i < resourceProviders[resourceOffers[resourceOfferId].resProvider].supportedFirstLayers.length; i++)\n        //     if (resourceProviders[resourceOffers[resourceOfferId].resProvider].supportedFirstLayers[i] == jobOffersPartTwo[jobOfferId].firstLayerHash)\n        //         RPSupportFirstLayer = true;\n\n        // for (i = 0; i < mediators[mediator].supportedFirstLayers.length; i++)\n        //     if (mediators[mediator].supportedFirstLayers[i] == jobOffersPartTwo[jobOfferId].firstLayerHash)\n        //         MSupportFirstLayer = true;\n\n\n        // require(\n        //     resourceOffers[resourceOfferId].instructionCap >= jobOffersPartOne[jobOfferId].instructionLimit &&\n        //     resourceOffers[resourceOfferId].memoryCap >= jobOffersPartTwo[jobOfferId].ramLimit &&\n        //     resourceOffers[resourceOfferId].localStorageCap >= jobOffersPartTwo[jobOfferId].localStorageLimit &&\n        //     resourceOffers[resourceOfferId].instructionPrice <= jobOffersPartOne[jobOfferId].instructionMaxPrice &&\n        //     resourceProviders[resourceOffers[resourceOfferId].resProvider].arch == jobOffersPartTwo[jobOfferId].arch && mediators[mediator].arch == resourceProviders[resourceOffers[resourceOfferId].resProvider].arch &&\n        //     resourceOffers[resourceOfferId].verificationCount <= mediators[mediator].verificationCount &&\n        //     now + resourceProviders[resourceOffers[resourceOfferId].resProvider].timePerInstruction * jobOffersPartOne[jobOfferId].instructionLimit <= jobOffersPartOne[jobOfferId].completionDeadline &&\n        //     RPTrustD && RPTrustM && JCTrustM && MTrustD && RPSupportFirstLayer && MSupportFirstLayer,\n        //     \"The offers cannot be matched\"\n        // );\n\n\n        uint256 index = matches.push(Match({\n            resourceOffer: resourceOfferId,\n            jobOffer: jobOfferId,\n            mediator: mediator\n        })) - 1;\n\n        jobOfferMatched[jobOfferId] = true;\n        resOfferMatched[resourceOfferId] = true;\n\n        uint256 matchIncentive = jobOffersPartOne[jobOfferId].matchIncentive +\n                resourceOffers[resourceOfferId].matchIncentive;\n\n        //msg.sender.transfer(matchIncentive);\n\n        emit EtherTransferred(address(this), msg.sender, matchIncentive, EtherTransferCause.PostMatch);\n\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT Matched\");\n        emit Matched(msg.sender, index, jobOfferId, resourceOfferId, mediator);\n\n        return index;\n    }\n\n    function postResult(\n        uint256 matchId,\n        uint256 jobOfferId,\n        ResultStatus status,\n        string uri,\n        string hash,\n        uint256 instructionCount,\n        uint256 bandwidthUsage\n    ) public returns (uint256) {\n        require(jobOfferId >= 0);\n\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ postResult\");\n        // require (resourceOffers[matches[matchId].resourceOffer].resProvider == msg.sender,\n        //     \"You are not supposed to publish result for this match.\");\n\n        // require(isMatchClosed[matchId] == false,\n        //     \"This match is already closed.\");\n\n        uint256 index = results.push(JobResult({\n            status: status,\n            matchId: matchId,\n            uri: uri,\n            instructionCount: instructionCount,\n            bandwidthUsage: bandwidthUsage,\n            hash: hash,\n            reacted: Reaction.None,\n            timestamp: now\n            })) - 1;\n\n        matchToResult[matchId] = index;\n        resultAvailable[matchId] = true;\n\n        // console.log(\"ðŸŸ¢ðŸŸ¢ðŸŸ¢ EMIT ResultPosted\");\n\n        emit ResultPosted(\n            msg.sender,\n            index,\n            matchId,\n            status,\n            uri,\n            hash,\n            instructionCount,\n            bandwidthUsage\n        );\n\n        return index;\n    }\n\n    function rejectResult(uint256 resultId, uint256 jobOfferId) public {\n        require(jobOfferId >= 0);\n        // require(jobOffersPartOne[matches[results[resultId].matchId].jobOffer].jobCreator == msg.sender,\n        //     \"You cannot reject a result which is not yours.\");\n        // require(results[resultId].reacted == Reaction.None,\n        //     \"You have already reacted to this result\");\n        // require(isMatchClosed[results[resultId].matchId] == false,\n        //     \"This match is already closed.\");\n\n        results[resultId].reacted = Reaction.Rejected;\n        mediationRequested[results[resultId].matchId] = true;\n\n        emit ResultReaction(msg.sender, resultId,results[resultId].matchId,  1);\n\n        emit DebugString(\"result rejected\");\n\n        emit JobAssignedForMediation(msg.sender, results[resultId].matchId);\n    }\n\n    function acceptResult(uint256 resultId, uint256 jobOfferId) public returns (uint256) {\n        require(jobOfferId >= 0);\n        //require(jobOffers[matches[results[resultId].matchId].jobOffer].jobCreator == msg.sender ||\n        //    (resourceOffers[matches[results[resultId].matchId].resourceOffer].resProvider == msg.sender && results[resultId].timestamp + reactionDeadline > now),\n        //    \"You cannot reject a result which is not yours or deadline has not been missed yet.\");\n        //require(results[resultId].reacted == Reaction.None,\n        //    \"You have already reacted to this result\");\n        //require(isMatchClosed[results[resultId].matchId] == false,\n        //    \"This match is already closed.\");\n\n        results[resultId].reacted = Reaction.Accepted;\n\n        emit ResultReaction(msg.sender, resultId,results[resultId].matchId,  0);\n\n        emit DebugString(\"result accepted\");\n\n        return close(results[resultId].matchId);\n\n    }\n\n\n    function postMediationResult(\n        uint256 matchId,\n        uint256 jobOfferId,\n        ResultStatus status,\n        string uri,\n\n        string hash,\n\n        uint256 instructionCount,\n        uint256 bandwidthUsage,\n\n        Verdict verdict,\n        Party faultyParty\n    ) public returns (Party) {\n        require(jobOfferId >= 0);\n        // require(matches[matchId].mediator == msg.sender, \"You are not this job's mediator\");\n        // require(mediationRequested[matchId] == true, \"JC did not request mediation for this match.\");\n        // require(mediated[matchId] == false, \"You have already mediated this match.\");\n\n        mediated[matchId] = true;\n\n        uint256 index = mediatorResults.push(MediatorResult({\n            status: status,\n            uri: uri,\n            matchId: matchId,\n            hash: hash,\n            instructionCount: instructionCount,\n            bandwidthUsage: bandwidthUsage,\n            verdict: verdict,\n            faultyParty: faultyParty\n        })) - 1;\n\n        uint256 cost = (instructionCount * mediators[msg.sender].instructionPrice +\n                        bandwidthUsage * mediators[msg.sender].bandwidthPrice) *\n                        resourceOffers[matches[matchId].resourceOffer].verificationCount;\n\n        // emit MediationResultPosted( index, faultyParty, verdict, matchId,\n        //                             status, uri, hash, instructionCount, bandwidthUsage, cost);\n\n        emit MediationResultPosted(matchId, msg.sender, index, faultyParty, verdict, status, uri, hash, instructionCount, cost);\n\n        punish(matchId, faultyParty);\n        //msg.sender.transfer(cost);\n        emit EtherTransferred(address(this), msg.sender, cost, EtherTransferCause.Mediation);\n        emit MatchClosed(matchId, cost);\n        return faultyParty;\n    }\n\n    function punish(uint256 matchId, Party faultyParty) private {\n        // require(isMatchClosed[matchId] == false, \"This match is already closed.\");\n        isMatchClosed[matchId] = true;\n\n        ResourceOffer memory ro = resourceOffers[matches[matchId].resourceOffer];\n        JobOfferPartOne memory jo = jobOffersPartOne[matches[matchId].jobOffer];\n\n        uint256 roDeposit = ro.depositValue;\n        uint256 joDeposit = jo.depositValue;\n\n        jo.depositValue = 0;\n        ro.depositValue = 0;\n\n        uint256 joValue = jo.bandwidthLimit * jo.bandwidthMaxPrice + jo.instructionLimit * jo.instructionMaxPrice;\n        uint256 roValue = ro.bandwidthCap * ro.bandwidthPrice + ro.instructionCap * ro.instructionPrice;\n\n        if (faultyParty == Party.JobCreator) {\n\n            //address(uint160(ro.resProvider)).transfer(roDeposit + roValue);\n            emit EtherTransferred(address(this), ro.resProvider, roDeposit + roValue, EtherTransferCause.Punishment);\n\n        } else if (faultyParty == Party.ResourceProvider) {\n\n            //address(uint160(jo.jobCreator)).transfer(joDeposit + joValue);\n            emit EtherTransferred(address(this), jo.jobCreator, joDeposit + joValue, EtherTransferCause.Punishment);\n        }\n    }\n\n    function close(uint256 matchId) private returns (uint256) {\n        //require(results[matchToResult[matchId]].reacted == Reaction.Accepted,\n        //    \"The job is not done yet.\");\n\n        JobResult memory r = results[matchToResult[matchId]];\n        ResourceOffer memory ro = resourceOffers[matches[matchId].resourceOffer];\n        // JobOfferPartOne memory jo = jobOffersPartOne[matches[matchId].jobOffer];\n        // address m = matches[matchId].mediator;\n\n        //require(isMatchClosed[matchId] == false, \"This match is already closed.\");\n        isMatchClosed[matchId] = true;\n\n        uint256 cost = r.instructionCount;\n\n        // uint256 cost = r.instructionCount * ro.instructionPrice +\n        //     r.bandwidthUsage * ro.bandwidthPrice;\n        // uint256 mediatorAvailabilityIncentive = mediators[m].availabilityValue;\n\n        // uint256 jo_deposit = jo.depositValue;\n        // uint256 ro_deposit = ro.depositValue;\n\n        // jo.depositValue = 0;\n        // ro.depositValue = 0;\n\n        //address(uint160(jo.jobCreator)).transfer(jo_deposit - cost - jo.matchIncentive - mediatorAvailabilityIncentive);\n        //address(uint160(ro.resProvider)).transfer(jo_deposit + cost - ro.matchIncentive - mediatorAvailabilityIncentive);\n        //address(uint160(m)).transfer(2 * mediatorAvailabilityIncentive);\n        // address(uint160(ro.resProvider)).transfer(cost);\n\n        ro.resProvider.transfer(cost);\n        emit MatchClosed(matchId, cost);\n        emit EtherTransferred(address(this), ro.resProvider, cost, EtherTransferCause.FinishingJob);\n        // emit EtherTransferred(address(this), jo.jobCreator, jo_deposit - cost, EtherTransferCause.FinishingJob);\n        // emit EtherTransferred(address(this), ro.resProvider, ro_deposit + cost, EtherTransferCause.FinishingResource);\n        // emit EtherTransferred(address(this), m, 2 * mediatorAvailabilityIncentive, EtherTransferCause.MediatorAvailability);\n\n        return cost;\n    }\n\n    function timeout(uint256 matchId, uint256 jobOfferId) public {\n        require(jobOfferId >= 0);\n        // require(jobOffersPartOne[matches[matchId].jobOffer].jobCreator == msg.sender,\n        //     \"You cannot make a timeout on this offer\");\n        // require(jobOffersPartOne[matches[matchId].jobOffer].completionDeadline < now,\n        //     \"RP has more time to finish this job\");\n        // require(isMatchClosed[matchId] == false,\n        //     \"This match is closed.\");\n\n        punish(matchId, Party.ResourceProvider);\n    }\n\n    function receiveValues(address toAccount, uint256 amount) public administrative {\n        address(uint160(toAccount)).transfer(amount);\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}